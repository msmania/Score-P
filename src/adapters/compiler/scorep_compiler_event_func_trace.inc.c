/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2013,
 * RWTH Aachen University, Germany
 *
 * Copyright (c) 2009-2013,
 * Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *
 * Copyright (c) 2009-2013, 2015, 2019-2020,
 * Technische Universitaet Dresden, Germany
 *
 * Copyright (c) 2009-2013,
 * University of Oregon, Eugene, USA
 *
 * Copyright (c) 2009-2013, 2022,
 * Forschungszentrum Juelich GmbH, Germany
 *
 * Copyright (c) 2009-2013,
 * German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *
 * Copyright (c) 2009-2013,
 * Technische Universitaet Muenchen, Germany
 *
 * This software may be modified and distributed under the terms of
 * a BSD-style license.  See the COPYING file in the package base
 * directory for details.
 */


/**
 * @file
 *
 * @brief Support for XL IBM-Compiler
 * Will be triggered by the function trace option by the xl
 * compiler.
 */

#include <stdlib.h>
#include <string.h>

#include <UTILS_IO.h>
#include <UTILS_CStr.h>

#include "scorep_compiler_demangle.h"

static UTILS_Mutex func_trace_register_region_mutex = UTILS_MUTEX_INIT;

/**
 * Looks up the region name in the hash table, registers the region
 * if it is not already registered and returns the region handle.
 * If the region is filtered it returns SCOREP_INVALID_REGION.
 * @ param regionName function name
 * @ param fileName   file name
 * @ param lineNo     line number
 */
static inline SCOREP_RegionHandle
func_trace_register_region( const char* regionName,
                            const char* fileName,
                            int         lineNo )
{
    UTILS_DEBUG_ENTRY( "%s in %s:%d", regionName, fileName, lineNo );

    size_t file_name_len = strlen( fileName );
    char   file_name[ file_name_len + 1 ];
    memcpy( file_name, fileName, file_name_len );
    file_name[ file_name_len ] = '\0';
    UTILS_IO_SimplifyPath( file_name );
    if ( SCOREP_Filtering_MatchFile( file_name ) )
    {
        return SCOREP_FILTERED_REGION;
    }

    SCOREP_RegionHandle region_handle = SCOREP_FILTERED_REGION;

    const char* region_name_demangled;
    scorep_compiler_demangle( regionName, region_name_demangled );
    /* Check for filters:
         1. In case OpenMP is used, the XL compiler creates some
            functions like <func_name>:<func_name>$OL$OL.1 on BG/P or
            <func_name>@OL@1 on AIX which cause the measurement system
            to crash. Thus, filter functions which names contain a '$'
            or '@' symbol.
            or the symbol starts with '__xl_' and has '_OL_' in it
         2. POMP and POMP2 functions.
     */
    if ( strchr( region_name_demangled, '$' ) ||
         strchr( region_name_demangled, '@' ) ||
         strncmp( region_name_demangled, "POMP", 4 ) == 0 ||
         strncmp( region_name_demangled, "Pomp", 4 ) == 0 ||
         strncmp( region_name_demangled, "pomp", 4 ) == 0 ||
         strstr( region_name_demangled, "Kokkos::Tools" ) ||
         strstr( region_name_demangled, "Kokkos::Profiling" ) ||
         /* Best effort at mangled name in case we don't have a demangler
            and demangled == mangled */
         strstr( region_name_demangled, "6Kokkos5Tools" ) ||
         strstr( region_name_demangled, "6Kokkos9Profiling" ) ||
         ( strncmp( region_name_demangled, "__xl_", 5 ) == 0 && strstr( region_name_demangled, "_OL_" ) ) ||
         SCOREP_Filtering_MatchFunction( region_name_demangled, regionName ) )
    {
        SCOREP_SourceFileHandle file_handle = SCOREP_Definitions_NewSourceFile( file_name );
        region_handle = SCOREP_Definitions_NewRegion( region_name_demangled,
                                                      regionName,
                                                      file_handle,
                                                      lineNo,
                                                      SCOREP_INVALID_LINE_NO,
                                                      SCOREP_PARADIGM_COMPILER,
                                                      SCOREP_REGION_FUNCTION );
    }

    return region_handle;
}


/* XL function signatures: see
 * https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1?topic=performance-tracing-functions-in-your-code
 * void __func_trace_enter(const char *const function_name, const char *const file_name, int line_number, void **const user_data);
 * void __func_trace_exit(const char *const function_name, const char *const file_name, int line_number, void **const user_data);
 * void __func_trace_catch(const char *const function_name, const char *const file_name, int line_number, void **const user_data);
 */

/**
 * @ brief This function is called at the entry of each function.
 * The call is generated by the IBM xl compilers
 *
 * @ param region_name function name
 * @ param file_name   file name
 * @ param line_no     line number
 */
void
__func_trace_enter( const char*  regionName,
                    const char*  fileName,
                    int          lineNo,
                    void** const userData )
{
    UTILS_BUILD_BUG_ON( sizeof( SCOREP_RegionHandle ) > sizeof( void* ) );

    SCOREP_IN_MEASUREMENT_INCREMENT();
    if ( SCOREP_IS_MEASUREMENT_PHASE( PRE ) )
    {
        SCOREP_InitMeasurement();
    }
    if ( !SCOREP_IS_MEASUREMENT_PHASE( WITHIN ) || SCOREP_IsUnwindingEnabled() )
    {
        SCOREP_IN_MEASUREMENT_DECREMENT();
        return;
    }

    uintptr_t handle = ( uintptr_t )
                       UTILS_Atomic_LoadN_void_ptr( &( *userData ),
                                                    UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
    if ( handle == 0 )
    {
        UTILS_MutexLock( &func_trace_register_region_mutex );
        handle = ( uintptr_t )
                 UTILS_Atomic_LoadN_void_ptr( &( *userData ),
                                              UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
        if ( handle == 0 )
        {
            handle = func_trace_register_region( regionName, fileName, lineNo );
            UTILS_Atomic_StoreN_void_ptr( &( *userData ),
                                          ( void* )handle,
                                          UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
        }
        UTILS_MutexUnlock( &func_trace_register_region_mutex );
    }
    if ( handle != SCOREP_FILTERED_REGION )
    {
        SCOREP_EnterRegion( ( SCOREP_RegionHandle )handle );
    }

    SCOREP_IN_MEASUREMENT_DECREMENT();
}

/**
 * @ brief This function is called at the exit of each function.
 * The call is generated by the IBM xl compilers
 *
 * @ param region_name function name
 * @ param file_name   file name
 * @ param line_no     line number
 */
void
__func_trace_exit( const char*  regionName,
                   const char*  fileName,
                   int          lineNo,
                   void** const userData )
{
    SCOREP_IN_MEASUREMENT_INCREMENT();
    if ( !SCOREP_IS_MEASUREMENT_PHASE( WITHIN ) || SCOREP_IsUnwindingEnabled() )
    {
        SCOREP_IN_MEASUREMENT_DECREMENT();
        return;
    }

    UTILS_DEBUG_ENTRY();

    SCOREP_RegionHandle handle = ( uintptr_t )
                                 UTILS_Atomic_LoadN_void_ptr( &( *userData ),
                                                              UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
    if ( handle != SCOREP_FILTERED_REGION )
    {
        SCOREP_ExitRegion( handle );
    }

    SCOREP_IN_MEASUREMENT_DECREMENT();
}
